/*
 * generated by Xtext 2.36.0
 */
package org.xtext.chalmers.qualitybt.serializer;

import btcpp.AlwaysFailureNode;
import btcpp.AlwaysSuccessNode;
import btcpp.BehaviorTree;
import btcpp.BlackboardCheckDouble;
import btcpp.BlackboardCheckInt;
import btcpp.BlackboardCheckString;
import btcpp.BtcppPackage;
import btcpp.FallbackNode;
import btcpp.ForceFailureNode;
import btcpp.ForceSuccessNode;
import btcpp.IfThenElseNode;
import btcpp.InverterNode;
import btcpp.KeepRunningUntilFailureNode;
import btcpp.MnualNode;
import btcpp.ParallelNode;
import btcpp.ReactiveFallback;
import btcpp.ReactiveSequence;
import btcpp.RepeatNode;
import btcpp.RetryNode;
import btcpp.Root;
import btcpp.SequenceNode;
import btcpp.SequenceStarNode;
import btcpp.SetBlackboardNode;
import btcpp.SimpleActionNode;
import btcpp.SimpleConditionNode;
import btcpp.SubTree;
import btcpp.SubtreeNode;
import btcpp.SwitchNode;
import btcpp.TimeoutNode;
import btcpp.TimerQueueNode;
import btcpp.WhileDoElseNode;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.chalmers.qualitybt.services.QualityBtGrammarAccess;

@SuppressWarnings("all")
public class QualityBtSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private QualityBtGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BtcppPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BtcppPackage.ALWAYS_FAILURE_NODE:
				sequence_AlwaysFailureNode(context, (AlwaysFailureNode) semanticObject); 
				return; 
			case BtcppPackage.ALWAYS_SUCCESS_NODE:
				sequence_AlwaysSuccessNode(context, (AlwaysSuccessNode) semanticObject); 
				return; 
			case BtcppPackage.BEHAVIOR_TREE:
				sequence_BehaviorTree(context, (BehaviorTree) semanticObject); 
				return; 
			case BtcppPackage.BLACKBOARD_CHECK_DOUBLE:
				sequence_BlackboardCheckDouble(context, (BlackboardCheckDouble) semanticObject); 
				return; 
			case BtcppPackage.BLACKBOARD_CHECK_INT:
				sequence_BlackboardCheckInt(context, (BlackboardCheckInt) semanticObject); 
				return; 
			case BtcppPackage.BLACKBOARD_CHECK_STRING:
				sequence_BlackboardCheckString(context, (BlackboardCheckString) semanticObject); 
				return; 
			case BtcppPackage.FALLBACK_NODE:
				sequence_FallbackNode(context, (FallbackNode) semanticObject); 
				return; 
			case BtcppPackage.FORCE_FAILURE_NODE:
				sequence_ForceFailureNode(context, (ForceFailureNode) semanticObject); 
				return; 
			case BtcppPackage.FORCE_SUCCESS_NODE:
				sequence_ForceSuccessNode(context, (ForceSuccessNode) semanticObject); 
				return; 
			case BtcppPackage.IF_THEN_ELSE_NODE:
				sequence_IfThenElseNode(context, (IfThenElseNode) semanticObject); 
				return; 
			case BtcppPackage.INVERTER_NODE:
				sequence_InverterNode(context, (InverterNode) semanticObject); 
				return; 
			case BtcppPackage.KEEP_RUNNING_UNTIL_FAILURE_NODE:
				sequence_KeepRunningUntilFailureNode(context, (KeepRunningUntilFailureNode) semanticObject); 
				return; 
			case BtcppPackage.MNUAL_NODE:
				sequence_MnualNode(context, (MnualNode) semanticObject); 
				return; 
			case BtcppPackage.PARALLEL_NODE:
				sequence_ParallelNode(context, (ParallelNode) semanticObject); 
				return; 
			case BtcppPackage.PARAMETER:
				sequence_Parameter(context, (btcpp.Parameter) semanticObject); 
				return; 
			case BtcppPackage.REACTIVE_FALLBACK:
				sequence_ReactiveFallback(context, (ReactiveFallback) semanticObject); 
				return; 
			case BtcppPackage.REACTIVE_SEQUENCE:
				sequence_ReactiveSequence(context, (ReactiveSequence) semanticObject); 
				return; 
			case BtcppPackage.REPEAT_NODE:
				sequence_RepeatNode(context, (RepeatNode) semanticObject); 
				return; 
			case BtcppPackage.RETRY_NODE:
				sequence_RetryNode(context, (RetryNode) semanticObject); 
				return; 
			case BtcppPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case BtcppPackage.SEQUENCE_NODE:
				sequence_SequenceNode(context, (SequenceNode) semanticObject); 
				return; 
			case BtcppPackage.SEQUENCE_STAR_NODE:
				sequence_SequenceStarNode(context, (SequenceStarNode) semanticObject); 
				return; 
			case BtcppPackage.SET_BLACKBOARD_NODE:
				sequence_SetBlackboardNode(context, (SetBlackboardNode) semanticObject); 
				return; 
			case BtcppPackage.SIMPLE_ACTION_NODE:
				sequence_SimpleActionNode(context, (SimpleActionNode) semanticObject); 
				return; 
			case BtcppPackage.SIMPLE_CONDITION_NODE:
				sequence_SimpleConditionNode(context, (SimpleConditionNode) semanticObject); 
				return; 
			case BtcppPackage.SUB_TREE:
				sequence_SubTree(context, (SubTree) semanticObject); 
				return; 
			case BtcppPackage.SUBTREE_NODE:
				sequence_SubtreeNode(context, (SubtreeNode) semanticObject); 
				return; 
			case BtcppPackage.SWITCH_NODE:
				sequence_SwitchNode(context, (SwitchNode) semanticObject); 
				return; 
			case BtcppPackage.TIMEOUT_NODE:
				sequence_TimeoutNode(context, (TimeoutNode) semanticObject); 
				return; 
			case BtcppPackage.TIMER_QUEUE_NODE:
				sequence_TimerQueueNode(context, (TimerQueueNode) semanticObject); 
				return; 
			case BtcppPackage.WHILE_DO_ELSE_NODE:
				sequence_WhileDoElseNode(context, (WhileDoElseNode) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns AlwaysFailureNode
	 *     LeafNode returns AlwaysFailureNode
	 *     ActionNodeBase returns AlwaysFailureNode
	 *     AlwaysFailureNode returns AlwaysFailureNode
	 *
	 * Constraint:
	 *     {AlwaysFailureNode}
	 * </pre>
	 */
	protected void sequence_AlwaysFailureNode(ISerializationContext context, AlwaysFailureNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns AlwaysSuccessNode
	 *     LeafNode returns AlwaysSuccessNode
	 *     ActionNodeBase returns AlwaysSuccessNode
	 *     AlwaysSuccessNode returns AlwaysSuccessNode
	 *
	 * Constraint:
	 *     (name=EString uID=EString? NodeType=NodeType? NodeStatus=NodeStatus? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_AlwaysSuccessNode(ISerializationContext context, AlwaysSuccessNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorTree returns BehaviorTree
	 *
	 * Constraint:
	 *     (ID=EString node+=TreeNode node+=TreeNode*)
	 * </pre>
	 */
	protected void sequence_BehaviorTree(ISerializationContext context, BehaviorTree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns BlackboardCheckDouble
	 *     DecoratorNode returns BlackboardCheckDouble
	 *     BlackboardCheckDouble returns BlackboardCheckDouble
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         return_on_mismatch=NodeStatus 
	 *         value_A=EString 
	 *         value_B=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_BlackboardCheckDouble(ISerializationContext context, BlackboardCheckDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns BlackboardCheckInt
	 *     DecoratorNode returns BlackboardCheckInt
	 *     BlackboardCheckInt returns BlackboardCheckInt
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         return_on_mismatch=NodeStatus 
	 *         value_A=EString 
	 *         value_B=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_BlackboardCheckInt(ISerializationContext context, BlackboardCheckInt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns BlackboardCheckString
	 *     DecoratorNode returns BlackboardCheckString
	 *     BlackboardCheckString returns BlackboardCheckString
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         return_on_mismatch=NodeStatus 
	 *         value_A=EString 
	 *         value_B=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_BlackboardCheckString(ISerializationContext context, BlackboardCheckString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns FallbackNode
	 *     ControlNode returns FallbackNode
	 *     FallbackNode returns FallbackNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_FallbackNode(ISerializationContext context, FallbackNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns ForceFailureNode
	 *     DecoratorNode returns ForceFailureNode
	 *     ForceFailureNode returns ForceFailureNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_ForceFailureNode(ISerializationContext context, ForceFailureNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns ForceSuccessNode
	 *     DecoratorNode returns ForceSuccessNode
	 *     ForceSuccessNode returns ForceSuccessNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_ForceSuccessNode(ISerializationContext context, ForceSuccessNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns IfThenElseNode
	 *     ControlNode returns IfThenElseNode
	 *     IfThenElseNode returns IfThenElseNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_IfThenElseNode(ISerializationContext context, IfThenElseNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns InverterNode
	 *     DecoratorNode returns InverterNode
	 *     InverterNode returns InverterNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_InverterNode(ISerializationContext context, InverterNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns KeepRunningUntilFailureNode
	 *     DecoratorNode returns KeepRunningUntilFailureNode
	 *     KeepRunningUntilFailureNode returns KeepRunningUntilFailureNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_KeepRunningUntilFailureNode(ISerializationContext context, KeepRunningUntilFailureNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns MnualNode
	 *     ControlNode returns MnualNode
	 *     MnualNode returns MnualNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_MnualNode(ISerializationContext context, MnualNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns ParallelNode
	 *     ControlNode returns ParallelNode
	 *     ParallelNode returns ParallelNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_ParallelNode(ISerializationContext context, ParallelNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, btcpp.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BtcppPackage.Literals.PARAMETER__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BtcppPackage.Literals.PARAMETER__KEY));
			if (transientValues.isValueTransient(semanticObject, BtcppPackage.Literals.PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BtcppPackage.Literals.PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getKeyEStringParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getParameterAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns ReactiveFallback
	 *     ControlNode returns ReactiveFallback
	 *     ReactiveFallback returns ReactiveFallback
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_ReactiveFallback(ISerializationContext context, ReactiveFallback semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns ReactiveSequence
	 *     ControlNode returns ReactiveSequence
	 *     ReactiveSequence returns ReactiveSequence
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_ReactiveSequence(ISerializationContext context, ReactiveSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns RepeatNode
	 *     DecoratorNode returns RepeatNode
	 *     RepeatNode returns RepeatNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         num_cycles=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_RepeatNode(ISerializationContext context, RepeatNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns RetryNode
	 *     DecoratorNode returns RetryNode
	 *     RetryNode returns RetryNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         num_attempts=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_RetryNode(ISerializationContext context, RetryNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     (main_tree_to_execute=EString behaviortrees+=BehaviorTree behaviortrees+=BehaviorTree*)
	 * </pre>
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SequenceNode
	 *     ControlNode returns SequenceNode
	 *     SequenceNode returns SequenceNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_SequenceNode(ISerializationContext context, SequenceNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SequenceStarNode
	 *     ControlNode returns SequenceStarNode
	 *     SequenceStarNode returns SequenceStarNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_SequenceStarNode(ISerializationContext context, SequenceStarNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SetBlackboardNode
	 *     LeafNode returns SetBlackboardNode
	 *     ActionNodeBase returns SetBlackboardNode
	 *     SetBlackboardNode returns SetBlackboardNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         value=EString 
	 *         output_key=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SetBlackboardNode(ISerializationContext context, SetBlackboardNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SimpleActionNode
	 *     LeafNode returns SimpleActionNode
	 *     ActionNodeBase returns SimpleActionNode
	 *     SimpleActionNode returns SimpleActionNode
	 *
	 * Constraint:
	 *     (name=EString uID=EString? NodeType=NodeType? NodeStatus=NodeStatus? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_SimpleActionNode(ISerializationContext context, SimpleActionNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SimpleConditionNode
	 *     LeafNode returns SimpleConditionNode
	 *     SimpleConditionNode returns SimpleConditionNode
	 *
	 * Constraint:
	 *     (name=EString uID=EString? NodeType=NodeType? NodeStatus=NodeStatus? (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_SimpleConditionNode(ISerializationContext context, SimpleConditionNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SubTree
	 *     SubTree returns SubTree
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (child+=TreeNode child+=TreeNode*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SubTree(ISerializationContext context, SubTree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubtreeNode returns SubtreeNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_SubtreeNode(ISerializationContext context, SubtreeNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns SwitchNode
	 *     ControlNode returns SwitchNode
	 *     SwitchNode returns SwitchNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_SwitchNode(ISerializationContext context, SwitchNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns TimeoutNode
	 *     DecoratorNode returns TimeoutNode
	 *     TimeoutNode returns TimeoutNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         msec=EString 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_TimeoutNode(ISerializationContext context, TimeoutNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns TimerQueueNode
	 *     DecoratorNode returns TimerQueueNode
	 *     TimerQueueNode returns TimerQueueNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child=TreeNode
	 *     )
	 * </pre>
	 */
	protected void sequence_TimerQueueNode(ISerializationContext context, TimerQueueNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeNode returns WhileDoElseNode
	 *     ControlNode returns WhileDoElseNode
	 *     WhileDoElseNode returns WhileDoElseNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         uID=EString? 
	 *         NodeType=NodeType? 
	 *         NodeStatus=NodeStatus? 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         child+=TreeNode 
	 *         child+=TreeNode*
	 *     )
	 * </pre>
	 */
	protected void sequence_WhileDoElseNode(ISerializationContext context, WhileDoElseNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
